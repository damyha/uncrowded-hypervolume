/*
 * optimal_hybrid_optimizer.cpp
 * This optimizer optimizes a problem by creating branches of populations where each branch is generated by applying
 * optimizers in parallel. The number of generations between branches is fixed
 *
 * Implementation by D. Ha
 */

#include "optimal_hybrid_optimizer.h"

#include "../fitness.h"
#include "../hillvallea_internal.hpp"

namespace hillvallea {
    /**
     * Constructor
     * @param fitness_function The UHV fitness function
     * @param number_of_parameters The number of parameters per solution set
     * @param lower_param_bounds The lower parameter bound
     * @param upper_param_bounds The upper parameter bound
     * @param init_univariate_bandwidth The univariate bandwith
     * @param optimizerIndexUHVGOMEA The linkage model index of UHV-GOMEA
     * @param optimizerIndexUHVADAM The version of UHV-ADAM [0:ADAM, 1:GAMO]
     * @param keep_track_of_statistics Boolean if statistics files need to be copied over
     * @param rng The rng object
     * @param write_directory The directory to write the statistics file to
     */
    optimal_hybrid_optimizer_t::optimal_hybrid_optimizer_t(
            std::shared_ptr<UHV_t> fitness_function,
            int reinitializeOptimizers,
            const size_t number_of_parameters,
            const vec_t &lower_param_bounds,
            const vec_t &upper_param_bounds,
            double init_univariate_bandwidth,
            int optimizerIndexUHVGOMEA,
            int optimizerIndexUHVADAM,
            int versionUHV_ADAM,
            size_t numberOFUHVGOMEACallsPerStep,
            size_t numberOfUHVADAMCallsPerStep,
            size_t maxMOEvaluationsPerGeneration,
            bool keep_track_of_statistics,
            rng_pt rng,
            std::string write_directory) : optimizer_t(
            number_of_parameters,
            lower_param_bounds,
            upper_param_bounds,
            init_univariate_bandwidth,
            fitness_function,
            rng) {
        // Copy settings
        this->optimizerIndexUHVGOMEA = optimizerIndexUHVGOMEA;
        this->optimizerIndexUHVADAM = optimizerIndexUHVADAM;
        this->uhvFitnessFunction = fitness_function;
        this->keepStatistics = keep_track_of_statistics;
        this->writeDirectory = write_directory;

        // Initialize variables
        this->active = false;
        this->populationInitialized = false;

        this->selection_fraction = 0.35;    // Taken from gomea.cpp
        this->use_boundary_repair = false;
//        this->estimateMOEvaluationsPerBranchUHV_GOMEA = 0;
//        this->estimateMOEvaluationsPerBranchUHV_ADAM = 0;

        // Optimizer Settings
        this->reinitializeOptimizers = reinitializeOptimizers;  // Should optimizers keep their history or be reinitialized every execution
        this->numberOfOptimizers = 2;                           // Should be calculated by counting number of optimizers to apply. Currently not used, but might be used if multiple statistics files are written.

        this->versionUHVADAM = versionUHV_ADAM;     // Method of applying UHV-ADAM on a population
        this->numberOFUHVGOMEACallsPerStep = numberOFUHVGOMEACallsPerStep;  // Number of UHV-GOMEA calls per branch
        this->numberOfUHVADAMCallsPerStep = numberOfUHVADAMCallsPerStep;    // Number of UHV-ADAM calls per branch

        this->maxNumberOfActiveBranches = 1;
        this->maxMOEvaluationsPerGeneration = maxMOEvaluationsPerGeneration;



        // Reset Branches
        this->resetOptimizationBranchVectors();
    }

    /**
     * Destructor
     */
    optimal_hybrid_optimizer_t::~optimal_hybrid_optimizer_t() {};


    /**
     * The name of the algorithm
     * @return The name of the algorithm
     */
    std::string optimal_hybrid_optimizer_t::name() const { return "UHV-OPTIMAL"; }

    /**
     * Resets the optimization branch vector and data
     */
    void optimal_hybrid_optimizer_t::resetOptimizationBranchVectors() {
        this->activeOptimizationBranches.resize(0);
        this->totalNumberOfOptimizationProcesses = 0;
    }

    /**
     * Removes all the parent nodes of the activeOptimizationBranches
     */
    void optimal_hybrid_optimizer_t::clearHistoryActiveOptimizationBranches()
    {
        // Collect all parent branches
        for(const auto &populationBranch:activeOptimizationBranches) {
            populationBranch->setParentBranch(nullptr);
        }
    }

    /**
     * Creates the initial optimization branch.
     * @param initial_population The initial population (presorted on fitness)
     */
    void optimal_hybrid_optimizer_t::initialize_from_population(population_pt initial_population) {
        // Reset Population branch data
        this->resetOptimizationBranchVectors();

        // Create new optimization branch
        gomea_pt optimizerUHV_GOMEA = createOptimizerUHV_GOMEA();
        adam_on_population_pt optimizerUHV_ADAM = createOptimizerUHV_ADAM();
        optimization_branch_pt initialBranch = std::make_shared<optimization_branch_t>(
                initial_population,
                optimizerUHV_GOMEA,
                optimizerUHV_ADAM,
                determineUHV_GOMEAOptimizerName(reinitializeOptimizers, optimizerIndexUHVGOMEA),
                determineUHV_ADAMOptimizerName(reinitializeOptimizers, optimizerIndexUHVADAM, versionUHVADAM));

        // Update statistics Todo: Quickfix to initialize evaluations (not via the fitness function)
        initialBranch->setCurrentNumberOfSoEvaluations(initial_population->size());
        initialBranch->setCurrentNumberOfMoEvaluations(this->uhvFitnessFunction->number_of_mo_evaluations);

        // Add initial population branch
        this->activeOptimizationBranches.push_back(initialBranch);
        this->totalNumberOfOptimizationProcesses = 1;

        // Set the best solution
        this->best = *initialBranch->getCurrentPopulation()->bestSolution();

        // Set default parameters
        this->active = true;
        this->populationInitialized = true;
    }

    /**
     * Execute a generation.
     * Every population branch keeps making branches (and applying the optimizers) until the maximum number of MO-evals
     * per branch is reached.
     * Only the best branches are kept for the next generation
     * @param sample_size The sample size
     *
     */
    void optimal_hybrid_optimizer_t::generation(size_t sample_size) {
        // Flush the parent branches from the active branches
        this->clearHistoryActiveOptimizationBranches();

        // Determine the MO-eval termination threshold
        size_t thresholdMOEvaluations =
                minimumNumberOfMOEvaluationsOfActivePopulationBranches() + this->maxMOEvaluationsPerGeneration;

        // Keep track of branches to investigate and branches that have reached the MO termination threshold.
        std::vector<optimization_branch_pt> currentBranchesToInvestigate = this->activeOptimizationBranches; // Only copies pointers
        std::vector<optimization_branch_pt> terminatedBranches;

        // Create reinitialization branch
        // This is done because sometimes the step size of UHV-ADAm seems to be misalligned
        if (!this->reinitializeOptimizers)
        {
            std::vector<optimization_branch_pt> reinitializedOptimizerBranches;
            for(const auto &branchSelected : currentBranchesToInvestigate)
            {
                // Create UHV-ADAM branch
                optimization_branch_pt branchUHV_ADAM = branchSelected->cloneOptimizationBranch();
                branchUHV_ADAM->setParentBranch(branchSelected);

                // Assign a reinitialized UHV-ADAM Optimizer
                adam_on_population_pt optimizerUHV_ADAM = createOptimizerUHV_ADAM();
                optimizerUHV_ADAM->initialize_from_population(branchUHV_ADAM->getCurrentPopulation(), branchUHV_ADAM->getCurrentPopulation()->size());
                branchUHV_ADAM->setOptimizerUhvAdam(optimizerUHV_ADAM);

                // Copy over other settings
                branchUHV_ADAM->setNameOptimizerUhvAdam(determineUHV_ADAMOptimizerName(true, this->optimizerIndexUHVADAM, this->versionUHVADAM));
                this->totalNumberOfOptimizationProcesses++;

                // Apply the reinitialized UHV-ADAM
                branchUHV_ADAM->applyUHV_ADAM(this->numberOfUHVADAMCallsPerStep,
                                              this->uhvFitnessFunction);

                reinitializedOptimizerBranches.push_back(branchUHV_ADAM);
            }

            // Add these reinitialized branches to the active branches
            for(const auto &branchSelected : reinitializedOptimizerBranches)
            {
                currentBranchesToInvestigate.push_back(branchSelected);
            }
        }

        // Keep splitting population branches until every branch satisfies 'thresholdMOEvaluations'
        while (!currentBranchesToInvestigate.empty()) {
//            printf("Number of branches to inspect: %ld, Terminated %ld/Total:%ld.\n", currentBranchesToInvestigate.size(), terminatedBranches.size(), currentBranchesToInvestigate.size()+terminatedBranches.size());
            std::vector<optimization_branch_pt> branchesNextIteration;

            // Go over all branches to investigate
            for (const auto &selectedBranch:currentBranchesToInvestigate) {
                // Split off branches
                optimization_branch_pt branchUHV_GOMEA, branchUHV_ADAM;

                // Do specific branch off
                if (this->reinitializeOptimizers) {
                    // Create UHV-GOMEA branch
                    gomea_pt optimizerUHV_GOMEA = createOptimizerUHV_GOMEA();
                    adam_on_population_pt optimizerUHV_ADAM = createOptimizerUHV_ADAM();

                    branchUHV_GOMEA = selectedBranch->cloneOptimizationBranch(
                            optimizerUHV_GOMEA,
                            optimizerUHV_ADAM,
                            determineUHV_GOMEAOptimizerName(this->reinitializeOptimizers, this->optimizerIndexUHVGOMEA),
                            determineUHV_ADAMOptimizerName(this->reinitializeOptimizers, this->optimizerIndexUHVADAM, this->versionUHVADAM));
                    branchUHV_GOMEA->setParentBranch(selectedBranch);
                    this->totalNumberOfOptimizationProcesses++;

                    // Create UHV-ADAM branch
                    optimizerUHV_GOMEA = createOptimizerUHV_GOMEA();
                    optimizerUHV_ADAM = createOptimizerUHV_ADAM();

                    branchUHV_ADAM = selectedBranch->cloneOptimizationBranch(
                            optimizerUHV_GOMEA,
                            optimizerUHV_ADAM,
                            determineUHV_GOMEAOptimizerName(this->reinitializeOptimizers, this->optimizerIndexUHVGOMEA),
                            determineUHV_ADAMOptimizerName(this->reinitializeOptimizers, this->optimizerIndexUHVADAM, this->versionUHVADAM));
                    branchUHV_ADAM->setParentBranch(selectedBranch);
                    this->totalNumberOfOptimizationProcesses++;

                } else {
                    // Create UHV-GOMEA branch
                    branchUHV_GOMEA = selectedBranch->cloneOptimizationBranch();
                    branchUHV_GOMEA->setParentBranch(selectedBranch);
                    this->totalNumberOfOptimizationProcesses++;

                    // Create UHV-ADAM branch
                    branchUHV_ADAM = selectedBranch->cloneOptimizationBranch();
                    branchUHV_ADAM->setNameOptimizerUhvAdam(determineUHV_ADAMOptimizerName(this->reinitializeOptimizers, this->optimizerIndexUHVADAM, this->versionUHVADAM));   // Quickfix that prevents copying reinit branch name's continuation
                    branchUHV_ADAM->setParentBranch(selectedBranch);
                    this->totalNumberOfOptimizationProcesses++;
                }

                // Execute the optimizers
                branchUHV_GOMEA->applyUHV_GOMEA(this->numberOFUHVGOMEACallsPerStep,
                                                this->uhvFitnessFunction);
                branchUHV_ADAM->applyUHV_ADAM(this->numberOfUHVADAMCallsPerStep,
                                              this->uhvFitnessFunction);


                // Check if the branches have reached the threshold
                if (branchUHV_GOMEA->getCurrentNumberOfMOEvaluations() >= thresholdMOEvaluations) {
                    terminatedBranches.push_back(branchUHV_GOMEA);
                } else {
                    branchesNextIteration.push_back(branchUHV_GOMEA);
                }

                // Check if the branches have reached the threshold
                if (branchUHV_ADAM->getCurrentNumberOfMOEvaluations() >= thresholdMOEvaluations) {
                    terminatedBranches.push_back(branchUHV_ADAM);
                } else {
                    branchesNextIteration.push_back(branchUHV_ADAM);
                }

            }

            currentBranchesToInvestigate = branchesNextIteration;

        }

        // Only keep the best branches
        std::vector<optimization_branch_pt> branchesToInvestigateNextGeneration =
                findBestPerformingOptimizationBranches(
                        terminatedBranches,
                        this->maxNumberOfActiveBranches);

        // Update the best solution
        this->best = solution_t(*branchesToInvestigateNextGeneration[0]->getCurrentPopulation()->bestSolution());

        // Set branches to investigate next generation
        this->activeOptimizationBranches = branchesToInvestigateNextGeneration;

        // Update statistics
        this->number_of_generations++;

    }

    /**
     * Determines the lowest number of MO-evaluations executed of every active population branch
     * @return The minimum number of MO-evaluations of every active population branch
     */
    size_t optimal_hybrid_optimizer_t::minimumNumberOfMOEvaluationsOfActivePopulationBranches() {
        size_t minimumNumberOfMOEvaluations = this->activeOptimizationBranches[0]->getCurrentNumberOfMOEvaluations();
        for (const auto &selectedBranch : this->activeOptimizationBranches) {
            double numberOfMOEvaluationsOfSelectedBranch = selectedBranch->getCurrentNumberOfMOEvaluations();

            if (numberOfMOEvaluationsOfSelectedBranch < minimumNumberOfMOEvaluations)
                minimumNumberOfMOEvaluations = numberOfMOEvaluationsOfSelectedBranch;
        }

        return minimumNumberOfMOEvaluations;
    }

    /**
     * Todo: implement selecting the best n branches
     * Selects the top-'numberOfBranches' optimization_branch objects with the best fitness
     * @param listOfOptimizationBranches A list of optimization_branch objects
     * @param numberOfBranches The number of branches to return
     * @return A vector of top performing optimization_branches
     */
    std::vector<optimization_branch_pt> optimal_hybrid_optimizer_t::findBestPerformingOptimizationBranches(
            std::vector<optimization_branch_pt> listOfOptimizationBranches,
            size_t numberOfBranches) {
        assert (numberOfBranches == 1); // Todo: Fix this
        std::vector<optimization_branch_pt> result;

        optimization_branch_pt optimizationBranchWithBestFitness = listOfOptimizationBranches[0];
        double bestFitness = optimizationBranchWithBestFitness->getCurrentPopulation()->best_fitness();

        for (size_t elementIndex = 1; elementIndex < listOfOptimizationBranches.size(); ++elementIndex) {
            optimization_branch_pt selectedOptimizationBranch = listOfOptimizationBranches[elementIndex];
            double fitnessSelectedBranch = selectedOptimizationBranch->getCurrentPopulation()->best_fitness();

            if (fitnessSelectedBranch < bestFitness) {
                optimizationBranchWithBestFitness = selectedOptimizationBranch;
                bestFitness = fitnessSelectedBranch;
            }
        }

        result.push_back(optimizationBranchWithBestFitness);
        return result;
    }

    /**
     * Closes all statistics files
     */
    void optimal_hybrid_optimizer_t::closeAllStatisticsFiles() {
        for (auto &populationBranch: this->activeOptimizationBranches)
            populationBranch->closeStatisticsFile();
    }

    /**
     * Create an UHV-GOMEA object
     * @return The UHV-GOMEA optimizer
     */
    gomea_pt optimal_hybrid_optimizer_t::createOptimizerUHV_GOMEA() {
        gomea_pt optimizerUHV_GOMEA = std::make_shared<gomea_t>(
                this->number_of_parameters,
                this->lower_param_bounds,
                this->upper_param_bounds,
                this->init_univariate_bandwidth,
                this->optimizerIndexUHVGOMEA,
                this->fitness_function,
                this->rng);

        return optimizerUHV_GOMEA;
    }

    /**
     * Creates an UHV-ADAM object
     * @return The UHV-ADAM optimizer
     */
    adam_on_population_pt optimal_hybrid_optimizer_t::createOptimizerUHV_ADAM() {
        adam_on_population_pt optimizerUHV_ADAM = std::make_shared<adam_on_population_t>(
                this->number_of_parameters,
                this->lower_param_bounds,
                this->upper_param_bounds,
                this->init_univariate_bandwidth,
                this->optimizerIndexUHVADAM,
                this->versionUHVADAM,
                this->fitness_function,
                this->rng);

        return optimizerUHV_ADAM;
    }

    /**
     * Determine the statistics file path of a new branch that is created.
     * @return The file path to the next statistics file
     */
    std::string optimal_hybrid_optimizer_t::determineNewBranchStatisticsFilePath() {
        return this->writeDirectory + "statistics_UHV-OPT_b" +
               std::to_string(this->totalNumberOfOptimizationProcesses) +
               ".dat";
    }

    /**
     * Returns the UHV-GOMEA's linkage model index as a string
     * @param reinitialized Is the optimizer reinitialized
     * @param uhv_gomea_linkage_model_index The linkage model index of UHV-GOMEA
     * @return The linakge model name of UHV-GOMEA
     */
    std::string optimal_hybrid_optimizer_t::determineUHV_GOMEAOptimizerName(int reinitialized,
                                                                            int uhv_gomea_linkage_model_index) {
        std::string result = "UHV-GOMEA";

        // Determine if reinitialized
        switch (reinitialized) {
            case 0:
                break;
            case 1:
                result += "-R";
                break;
            default:
                result += "-Unknown";
                break;
        }

        // Determine linkage
        switch (uhv_gomea_linkage_model_index) {
            case 64:
                result += "-Lm";
                break;
            case 66:
                result += "-Lt";
                break;
            case 50:
                result += "-Lf";
                break;
            default:
                result += "-Unknown";
                break;
        }

        return result;
    }

    /**
     * Returns the optimizer name of UHV-ADAM/GAMO and its version
     * @param reinitialized Is the optimizer reinitialized
     * @param versionUHV_ADAM The version of the UHV-Gradient [50: ADAM, 64:GAMO]
     * @param methodUHV_ADAM The version of UHV-ADAM [0:best, 1:All, 2:Top3]
     * @return The optimizer name and version as a string
     */
    std::string optimal_hybrid_optimizer_t::determineUHV_ADAMOptimizerName(int reinitialized,
                                                                           int versionUHV_ADAM,
                                                                           int methodUHV_ADAM) {
        std::string result = "UHV";

        // Determine the Algorithm Name
        switch (versionUHV_ADAM) {
            case 50:
                result += "-ADAM";
                break;
            case 64:
                result += "-GAMO";
                break;
            default:
                result += "-Unknown";
                break;
        }

        // Determine if reinitialized
        switch (reinitialized) {
            case 0:
                break;
            case 1:
                result += "-R";
                break;
            default:
                result += "-Unknown";
                break;
        }

        // Determine application method name
        switch (methodUHV_ADAM) {
            case 0 :
                result += "-Best";
                break;
            case 1 :
                result += "-All";
                break;
            case 2 :
                result += "-TOP3";
                break;
            case 3:
                result += "-Random";
                break;
            default:
                result += "-Unknown";
                break;
        }

        return result;
    }
}

